
C:/Users/ngocp/OneDrive/Documents/Github/ECE3610/lab02/getting_started.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <__cs3_interrupt_vector>:
 ********************************************************************************/
.text        /* executable code follows */
.global     _start 
_start:                         

        LDR     R1, =LED_BASE   // base address of LED lights
   0:	e59f1078 	ldr	r1, [pc, #120]	; 80 <LED_for_correct_password+0x4>
        LDR     R2, =SW_BASE    // base address of SW switches
   4:	e59f2078 	ldr	r2, [pc, #120]	; 84 <LED_for_correct_password+0x8>
        LDR     R3, =KEY_BASE   // base address of KEY pushbuttons
   8:	e59f3078 	ldr	r3, [pc, #120]	; 88 <LED_for_correct_password+0xc>

        MOV     R4, #0          // value for LED displays when incorrect password
   c:	e3a04000 	mov	r4, #0
        LDR     R11, LED_for_correct_password   // value for LED displays when correct password (#0bAAAAAAAA = 1010... for 32-bit)
  10:	e59fb064 	ldr	r11, [pc, #100]	; 7c <LED_for_correct_password>

00000014 <WAIT>:

WAIT:
        LDR     R12, password   // value of password stored in memory (#0b10011011)
  14:	e59fc05c 	ldr	r12, [pc, #92]	; 78 <password>
        LDR     R5, [R2]        // load SW to processor's register
  18:	e5925000 	ldr	r5, [r2]
        LDR     R6, [R3]        // load KEY to processor's register
  1c:	e5936000 	ldr	r6, [r3]

        CMP     R6, #1          // check if KEY #0 is pressed
  20:	e3560001 	cmp	r6, #1
        BEQ     CHECK_PASSWORD
  24:	0a000000 	beq	2c <CHECK_PASSWORD>
        BNE     WAIT
  28:	1afffff9 	bne	14 <WAIT>

0000002c <CHECK_PASSWORD>:

CHECK_PASSWORD:
        CMP     R5, R12        // check R4 (SW) with R5 (password in memory #0b10011011)
  2c:	e155000c 	cmp	r5, r12
        BEQ     CORRECT_PASSWORD //jump to correct_password
  30:	0a000001 	beq	3c <CORRECT_PASSWORD>
        STR     R4, [R1]        // incorrect password, no LEDs (#0)
  34:	e5814000 	str	r4, [r1]
        BNE     WAIT            // loop back to check for SW combination
  38:	1afffff5 	bne	14 <WAIT>

0000003c <CORRECT_PASSWORD>:

//display LED to indicate correct password
CORRECT_PASSWORD:
        STR     R11, [R1]       // store a pre-defined pattern R11 to the LED displays [R1]
  3c:	e581b000 	str	r11, [r1]
        ROR     R11, #1         // rotate LEDs to the right by 1
  40:	e1a0b0eb 	ror	r11, r11, #1

        LDR     R6, =100000000   // delay counter        
  44:	e59f6040 	ldr	r6, [pc, #64]	; 8c <LED_for_correct_password+0x10>
        B       DELAY
  48:	eaffffff 	b	4c <DELAY>

0000004c <DELAY>:
DELAY:                          
        SUBS    R6, R6, #1      
  4c:	e2566001 	subs	r6, r6, #1
        BNE     DELAY           
  50:	1afffffd 	bne	4c <DELAY>

        LDR     R6, [R3]        // load current value of SW back to R6 in processor
  54:	e5936000 	ldr	r6, [r3]
        CMP     R6, #1
  58:	e3560001 	cmp	r6, #1
        BEQ     WAIT            //  if KEY #0 pressed, jump back to wait for load SW combination again
  5c:	0affffec 	beq	14 <WAIT>
        CMP     R6, #4          // check if KEY #3 is pressed          
  60:	e3560004 	cmp	r6, #4
        BNE     CORRECT_PASSWORD // if KEY #0 not pressed, continue displaying LEDs of correct password
  64:	1afffff4 	bne	3c <CORRECT_PASSWORD>
        BEQ     UPDATE_PASSWORD
  68:	0affffff 	beq	6c <UPDATE_PASSWORD>

0000006c <UPDATE_PASSWORD>:




UPDATE_PASSWORD:
        LDR     R5, [R2]
  6c:	e5925000 	ldr	r5, [r2]
        STR     R5, password
  70:	e58f5000 	str	r5, [pc]	; 78 <password>
        B       WAIT
  74:	eaffffe6 	b	14 <WAIT>

00000078 <password>:
  78:	0000009b 	.word	0x0000009b

0000007c <LED_for_correct_password>:
  7c:	aaaaaaaa 	.word	0xaaaaaaaa
  80:	ff200000 	.word	0xff200000
  84:	ff200040 	.word	0xff200040
  88:	ff200050 	.word	0xff200050
  8c:	05f5e100 	.word	0x05f5e100
